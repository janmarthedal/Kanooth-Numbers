% $Id: index.html 84 2010-06-14 15:00:39Z jan_marthedal $

\documentclass[a4paper]{article}

\usepackage{amsmath}
\usepackage[dvips]{hyperref}

\begin{document}

\title{Sputsoft Numbers}
\author{Jan Marthedal Rasmussen}

\maketitle


Sputsoft Numbers is a C++ library for doing multiple-precision arithmetic. The underlying theory and design can be found among the \href{http://sputsoft.com/tag/multiple-precision/}{multiple-precision articles}.

The library is header-only and highly portable, relying only on some \href{http://www.boost.org}{boost} libraries. It is possible, however, to obtain highly optimized code by choosing the \href{http://gmplib.org/}{GMP} backend. This requires no code changes, but only setting a preprocessor macro and linking to the GMP library (see below).


%-------------------------------------
\section{Installation and Basic Usage}
%-------------------------------------

Since the library is header-only, you only need to place all the files from the library somewhere locally and instruct your C++ compiler to use the directory containing the \texttt{sputsoft} folder as an include directory. The \href{http://www.boost.org}{boost} libraries needed are \href{http://www.boost.org/doc/libs/1_43_0/libs/integer/doc/html/boost_integer/traits.html}{integer traits} and \href{http://www.boost.org/doc/libs/1_43_0/libs/smart_ptr/shared_ptr.htm}{shared pointer}. So, assuming that boost is somewhere among your compiler's standard include search paths, you should be able to compile using, e.g.,
\begin{verbatim}
  g++ -I. test.cpp
\end{verbatim}
if using the GNU C++ compiler and the current directory contains the \texttt{sputsoft} folder.

By default, the library uses generic and portable C++ code for the low-level arithmetic routines. If you wish to use the low-level routines from the \href{http://gmplib.org}{GMP} library, you can compile the program from above as
\begin{verbatim}
  g++ -I. test.cpp -DSPUTSOFT_USE_GMP -lgmp
\end{verbatim}
assuming that the GMP library is installed and available on the platform.

Unless explicitly stated, every data type and function from the library reside in the \texttt{sputsoft::numbers} namespace.


%-------------------
\section{Data Types}
%-------------------

The data types currently supported are \texttt{natural\_number} and \texttt{integer}. They are initialized when declared and automatically clean up when going out of scope.

When the following refers to built-in unsigned integers, it refers to \texttt{unsigned short int}, \texttt{unsigned int}, \texttt{unsigned long int}, and \texttt{unsigned long long int} if the compiler supports it. Built-in signed integers refer to \texttt{signed short int}, \texttt{signed int}, \texttt{signed long int}, and \texttt{signed long long int} if the compiler supports it.

\subsection{Named Operators}

All functions operating on these numbers have the form \emph{name(output numbers, ..., input numbers, ...)}. For instance, \texttt{add(z, x, y)} adds \texttt{x} and \texttt{y} and puts the result into \texttt{z}.

Unless noted otherwise below, the following rules hold for each function \emph{bin\_func}\texttt{(z, x, y)} representing a binary operator:
\begin{itemize}
\item If \texttt{z} is of type \texttt{integer} then either \texttt{x} or \texttt{y} must be a \texttt{natural\_number} or an \texttt{integer}, and the other argument must be an \texttt{integer}, a \texttt{natural\_number}, a built-in signed integer, or an built-in unsigned integer.
\item If \texttt{z} is of type \texttt{natural\_number} then either \texttt{x} or \texttt{y} must be a \texttt{natural\_number}, and the other argument must be a \texttt{natural\_number}, an unsigned built-in integer, or a non-negative \texttt{int} (to support literal constants).
\end{itemize}

Most functions also have return-by-value versions that create a temporary object to put the result into. For instance, the following two lines do the same thing:
\begin{verbatim}
  add(z, x, y);
  set(z, add(x, y));
\end{verbatim}
The first of these statements, however, is likely to be more efficient since creating a temporary may be avoidable.

Unless noted otherwise, the following rules hold for each function \emph{bin\_func}\texttt{(x, y)} representing a binary operator:
\begin{itemize}
\item If one argument is an \texttt{integer} and the other argument is an \texttt{integer}, a \texttt{natural\_number}, a signed built-in integer, or an unsigned built-in integer, then the result is an \texttt{integer}.
\item If one argument is a \texttt{natural\_number} and the other argument is a \texttt{natural\_number}, an unsigned built-in integer, or a non-negative \texttt{int}, then the result is a \texttt{natural\_number}.
\end{itemize}

For unary operators \emph{un\_func}\texttt{(z, x)}, the types of \texttt{z} and \texttt{x} should be the same. Similarly, the value-returning unary functions \emph{un\_func}\texttt{(x)} return a value of the same type. Exceptions to these general rules are noted below.

\subsection{Overloaded Operators}

The binary operators \texttt{=}, \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, and \texttt{\%} have been overloaded to represent \texttt{set}, \texttt{add}, \texttt{sub}, \texttt{mul}, \texttt{div}, and \texttt{rem}, respectively. The unary \texttt{-} corresponds to \texttt{negate}. There is no one-to-one correspondence, though, and optimizations are often applied in compound expressions. For instance, \texttt{z = x + y} translates into \texttt{add(z, x, y)} and not the direct translation \texttt{set(z, add(x, y))}, which creates a temporary number to hold the sum.

\subsection{Passing and Returning by Value}

The magnitude of each number is pointed to using reference counting. This makes passing and returning by value extremely cheap.


%--------------------------------------
\section{Initialization and Assignment}
%--------------------------------------

\subsection{Natural Number details}

Natural numbers can be initialized in five ways:
\begin{itemize}
\item No initializer (set to zero).
\item Set to built-in unsigned integer.
\item Set to non-negative \texttt{int} (to support literal constants).
\item Set to C/C++ string (\texttt{const char*} or \texttt{std::string})
\item Set to the value of another variable of the same type.
\end{itemize}

For instance:
\begin{verbatim}
  natural_number a;
  natural_number b = 42u;
  natural_number c = 97;
  natural_number d = "1234";
  natural_number e = b;
\end{verbatim}

After initialization, the same (non-empty) right-hand sides can be used for assignment using \texttt{set} or \texttt{=}, e.g.,
\begin{verbatim}
  set(b, 3u);
  set(c, "5432");
  set(d, a);
  b = 4;
  c = "987";
  d = c;
\end{verbatim}

\subsection{Integer details}

The number type \texttt{integer} can be initialized using the same right-hand sides as \texttt{natural\_number}s. In addition, built-in signed integers can be used and the C/C++ strings can have leading \texttt{+}'s or \texttt{-}'s. For instance:
\begin{verbatim}
  integer a;
  integer b = 3l;
  integer c = "-1234";
  integer d = b;
\end{verbatim}
Again, the same (non-empty) right-hand sides can be used for assignment using \texttt{set} or \texttt{=}.


%------------------------------------
\section{Positive, Negative, or Zero}
%------------------------------------

The functions \texttt{is\_positive}, \texttt{is\_negative}, \texttt{is\_zero} tell whether a number is positive, negative, or zero, respectively. \texttt{integer}s can have their sign changed using \texttt{negate} or the unary \texttt{-}:
\begin{verbatim}
  negate(z, x);  set(z, negate(x));  z = -x;
\end{verbatim}

The library's numbers have implicit conversion to \texttt{bool}, which makes it possible to check if a number is zero, e.g.:
\begin{verbatim}
  void f(integer x) {
    std::cout << "Variable is " << (x ? "non-zero" : "zero") << std::endl;
  }
\end{verbatim}

The absolute value of a number can be obtained using \texttt{abs}.


%--------------------------------------------------
\section{Addition, Subtraction, and Multiplication}
%--------------------------------------------------

These operations are performed by \texttt{add}/\texttt{+}, \texttt{sub}/\texttt{-}, and \texttt{mul}/\texttt{*}. Both result-to-reference and return-by-value forms are supported, such that each of the following lines perform semantically equivalent computations:
\begin{verbatim}
  add(z, x, y);  set(z, add(x, y));  z = x + y;
  sub(z, x, y);  set(z, sub(x, y));  z = x - y;
  mul(z, x, y);  set(z, mul(x, y));  z = x * y;
\end{verbatim}
As mentioned earlier, the result-to-reference forms are likely to be faster than the return-by-value forms.

\subsection{Argument Type Exceptions}

For \texttt{sub(z, x, y)} with \texttt{z} a \texttt{natural\_number}, then \texttt{x} must be a \texttt{natural\_number}. \texttt{sub(x, y)} with \texttt{x} a built-in integer and \texttt{y} a \texttt{natural\_number} is not supported.

%-------------------------------
\section{Quotient and Remainder}
%-------------------------------

The quotient of dividing two numbers is obtained using \texttt{div} or \texttt{/}, the remainder using \texttt{rem} or \texttt{\%}. Unless noted otherwise, the return type of \texttt{div(x, y)} is the same as the type for \texttt{x}. The return type of \texttt{rem(x, y)} is the same as the type for \texttt{y}.

Whenever computation of the remainder is supported, the following always holds:
\begin{verbatim}
  x == div(x, y) * y + rem(x, y)
\end{verbatim}

Both the quotient and the remainder can be obtained through a single call using \texttt{quotrem}. The result-to-reference version of this function is \texttt{quotrem(q, r, x, y)}, which is semantically equivalent to:
\begin{verbatim}
  div(q, x, y);
  rem(r, x, y);
\end{verbatim}

The return-by-value version is \texttt{quotrem(q, x, y)}, where the quotient is put in \texttt{q} and the remainder is returned:
\begin{verbatim}
  set(r, quotrem(q, x, y));
\end{verbatim}

\subsection{Integer details}

Three different forms of rounding is avaiable for \texttt{integer}s:
\begin{itemize}
\item The quotient is rounded towards minus infinity: \texttt{div\_floor}, \texttt{rem\_floor}, and \texttt{quotrem\_floor}.
\item The quotient is rounded towards plus infinity: \texttt{div\_ceil}, \texttt{rem\_ceil}, and \texttt{quotrem\_ceil}.
\item The quotient is rounded towards zero: \texttt{div\_trunc}, \texttt{rem\_trunc}, and \texttt{quotrem\_trunc}.
\end{itemize}
As mentioned earlier, each \texttt{rem}-function fits the corresponding \texttt{div}-function such that, e.g.:
\begin{verbatim}
  x == div_ceil(x, y) * y + rem_ceil(x, y)
\end{verbatim}

The functions \texttt{div} and \texttt{rem} are synonymous with \texttt{div\_floor} and \texttt{rem\_floor}, respectively.


%--------------------
\section{Comparisons}
%--------------------

Equality can be determined by \texttt{equal}. \texttt{compare(x, y)} $\rightarrow$ \texttt{int} returns a negative/positive/zero value if \texttt{x} is strictly less than/strictly greater than/equal to \texttt{y}.

The operators \texttt{==}, \texttt{!=}, \texttt{<}, \texttt{>}, \texttt{<=}, \texttt{>=} are all overloaded.


%------------------------------------
\section{Source Code and Downloading}
%------------------------------------

The current release is version 0.2 and is \href{http://sourceforge.net/projects/sputsoftnumbers/}{hosted} at \href{http://sourceforge.net}{SourceForge}. The library can be \href{https://sourceforge.net/projects/sputsoftnumbers/files/}{downloaded} or the latest source code can be \href{http://sputsoftnumbers.svn.sourceforge.net/viewvc/sputsoftnumbers/trunk/}{browsed}.

Bug reports, suggestions for improvements, and other comments are very welcome.

\end{document}

